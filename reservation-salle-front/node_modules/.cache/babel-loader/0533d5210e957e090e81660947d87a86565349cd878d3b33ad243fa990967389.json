{"ast":null,"code":"import { PureComponent, createElement } from 'react';\nimport { array, arrayOf, func, number, object, oneOf, oneOfType, string } from 'prop-types';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n  return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n}\nvar ALIGNMENT;\n(function (ALIGNMENT) {\n  ALIGNMENT[\"AUTO\"] = \"auto\";\n  ALIGNMENT[\"START\"] = \"start\";\n  ALIGNMENT[\"CENTER\"] = \"center\";\n  ALIGNMENT[\"END\"] = \"end\";\n})(ALIGNMENT || (ALIGNMENT = {}));\nvar DIRECTION;\n(function (DIRECTION) {\n  DIRECTION[\"HORIZONTAL\"] = \"horizontal\";\n  DIRECTION[\"VERTICAL\"] = \"vertical\";\n})(DIRECTION || (DIRECTION = {}));\nvar SCROLL_CHANGE_REASON;\n(function (SCROLL_CHANGE_REASON) {\n  SCROLL_CHANGE_REASON[\"OBSERVED\"] = \"observed\";\n  SCROLL_CHANGE_REASON[\"REQUESTED\"] = \"requested\";\n})(SCROLL_CHANGE_REASON || (SCROLL_CHANGE_REASON = {}));\nvar scrollProp = (_a = {}, _a[DIRECTION.VERTICAL] = 'scrollTop', _a[DIRECTION.HORIZONTAL] = 'scrollLeft', _a);\nvar sizeProp = (_b = {}, _b[DIRECTION.VERTICAL] = 'height', _b[DIRECTION.HORIZONTAL] = 'width', _b);\nvar positionProp = (_c = {}, _c[DIRECTION.VERTICAL] = 'top', _c[DIRECTION.HORIZONTAL] = 'left', _c);\nvar marginProp = (_d = {}, _d[DIRECTION.VERTICAL] = 'marginTop', _d[DIRECTION.HORIZONTAL] = 'marginLeft', _d);\nvar oppositeMarginProp = (_e = {}, _e[DIRECTION.VERTICAL] = 'marginBottom', _e[DIRECTION.HORIZONTAL] = 'marginRight', _e);\nvar _a;\nvar _b;\nvar _c;\nvar _d;\nvar _e;\n\n/* Forked from react-virtualized ðŸ’– */\nvar SizeAndPositionManager = /** @class */function () {\n  function SizeAndPositionManager(_a) {\n    var itemCount = _a.itemCount,\n      itemSizeGetter = _a.itemSizeGetter,\n      estimatedItemSize = _a.estimatedItemSize;\n    this.itemSizeGetter = itemSizeGetter;\n    this.itemCount = itemCount;\n    this.estimatedItemSize = estimatedItemSize;\n    // Cache of size and position data for items, mapped by item index.\n    this.itemSizeAndPositionData = {};\n    // Measurements for items up to this index can be trusted; items afterward should be estimated.\n    this.lastMeasuredIndex = -1;\n  }\n  SizeAndPositionManager.prototype.updateConfig = function (_a) {\n    var itemCount = _a.itemCount,\n      itemSizeGetter = _a.itemSizeGetter,\n      estimatedItemSize = _a.estimatedItemSize;\n    if (itemCount != null) {\n      this.itemCount = itemCount;\n    }\n    if (estimatedItemSize != null) {\n      this.estimatedItemSize = estimatedItemSize;\n    }\n    if (itemSizeGetter != null) {\n      this.itemSizeGetter = itemSizeGetter;\n    }\n  };\n  SizeAndPositionManager.prototype.getLastMeasuredIndex = function () {\n    return this.lastMeasuredIndex;\n  };\n  /**\n   * This method returns the size and position for the item at the specified index.\n   * It just-in-time calculates (or used cached values) for items leading up to the index.\n   */\n  SizeAndPositionManager.prototype.getSizeAndPositionForIndex = function (index) {\n    if (index < 0 || index >= this.itemCount) {\n      throw Error(\"Requested index \" + index + \" is outside of range 0..\" + this.itemCount);\n    }\n    if (index > this.lastMeasuredIndex) {\n      var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n      var offset = lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size;\n      for (var i = this.lastMeasuredIndex + 1; i <= index; i++) {\n        var size = this.itemSizeGetter(i);\n        if (size == null || isNaN(size)) {\n          throw Error(\"Invalid size returned for index \" + i + \" of value \" + size);\n        }\n        this.itemSizeAndPositionData[i] = {\n          offset: offset,\n          size: size\n        };\n        offset += size;\n      }\n      this.lastMeasuredIndex = index;\n    }\n    return this.itemSizeAndPositionData[index];\n  };\n  SizeAndPositionManager.prototype.getSizeAndPositionOfLastMeasuredItem = function () {\n    return this.lastMeasuredIndex >= 0 ? this.itemSizeAndPositionData[this.lastMeasuredIndex] : {\n      offset: 0,\n      size: 0\n    };\n  };\n  /**\n   * Total size of all items being measured.\n   * This value will be completedly estimated initially.\n   * As items as measured the estimate will be updated.\n   */\n  SizeAndPositionManager.prototype.getTotalSize = function () {\n    var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n    return lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size + (this.itemCount - this.lastMeasuredIndex - 1) * this.estimatedItemSize;\n  };\n  /**\n   * Determines a new offset that ensures a certain item is visible, given the alignment.\n   *\n   * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\n   * @param containerSize Size (width or height) of the container viewport\n   * @return Offset to use to ensure the specified item is visible\n   */\n  SizeAndPositionManager.prototype.getUpdatedOffsetForIndex = function (_a) {\n    var _b = _a.align,\n      align = _b === void 0 ? ALIGNMENT.START : _b,\n      containerSize = _a.containerSize,\n      currentOffset = _a.currentOffset,\n      targetIndex = _a.targetIndex;\n    if (containerSize <= 0) {\n      return 0;\n    }\n    var datum = this.getSizeAndPositionForIndex(targetIndex);\n    var maxOffset = datum.offset;\n    var minOffset = maxOffset - containerSize + datum.size;\n    var idealOffset;\n    switch (align) {\n      case ALIGNMENT.END:\n        idealOffset = minOffset;\n        break;\n      case ALIGNMENT.CENTER:\n        idealOffset = maxOffset - (containerSize - datum.size) / 2;\n        break;\n      case ALIGNMENT.START:\n        idealOffset = maxOffset;\n        break;\n      default:\n        idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\n    }\n    var totalSize = this.getTotalSize();\n    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n  };\n  SizeAndPositionManager.prototype.getVisibleRange = function (_a) {\n    var containerSize = _a.containerSize,\n      offset = _a.offset,\n      overscanCount = _a.overscanCount;\n    var totalSize = this.getTotalSize();\n    if (totalSize === 0) {\n      return {};\n    }\n    var maxOffset = offset + containerSize;\n    var start = this.findNearestItem(offset);\n    if (typeof start === 'undefined') {\n      throw Error(\"Invalid offset \" + offset + \" specified\");\n    }\n    var datum = this.getSizeAndPositionForIndex(start);\n    offset = datum.offset + datum.size;\n    var stop = start;\n    while (offset < maxOffset && stop < this.itemCount - 1) {\n      stop++;\n      offset += this.getSizeAndPositionForIndex(stop).size;\n    }\n    if (overscanCount) {\n      start = Math.max(0, start - overscanCount);\n      stop = Math.min(stop + overscanCount, this.itemCount - 1);\n    }\n    return {\n      start: start,\n      stop: stop\n    };\n  };\n  /**\n   * Clear all cached values for items after the specified index.\n   * This method should be called for any item that has changed its size.\n   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\n   */\n  SizeAndPositionManager.prototype.resetItem = function (index) {\n    this.lastMeasuredIndex = Math.min(this.lastMeasuredIndex, index - 1);\n  };\n  /**\n   * Searches for the item (index) nearest the specified offset.\n   *\n   * If no exact match is found the next lowest item index will be returned.\n   * This allows partially visible items (with offsets just before/above the fold) to be visible.\n   */\n  SizeAndPositionManager.prototype.findNearestItem = function (offset) {\n    if (isNaN(offset)) {\n      throw Error(\"Invalid offset \" + offset + \" specified\");\n    }\n    // Our search algorithms find the nearest match at or below the specified offset.\n    // So make sure the offset is at least 0 or no match will be found.\n    offset = Math.max(0, offset);\n    var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n    var lastMeasuredIndex = Math.max(0, this.lastMeasuredIndex);\n    if (lastMeasuredSizeAndPosition.offset >= offset) {\n      // If we've already measured items within this range just use a binary search as it's faster.\n      return this.binarySearch({\n        high: lastMeasuredIndex,\n        low: 0,\n        offset: offset\n      });\n    } else {\n      // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n      // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n      // The overall complexity for this approach is O(log n).\n      return this.exponentialSearch({\n        index: lastMeasuredIndex,\n        offset: offset\n      });\n    }\n  };\n  SizeAndPositionManager.prototype.binarySearch = function (_a) {\n    var low = _a.low,\n      high = _a.high,\n      offset = _a.offset;\n    var middle = 0;\n    var currentOffset = 0;\n    while (low <= high) {\n      middle = low + Math.floor((high - low) / 2);\n      currentOffset = this.getSizeAndPositionForIndex(middle).offset;\n      if (currentOffset === offset) {\n        return middle;\n      } else if (currentOffset < offset) {\n        low = middle + 1;\n      } else if (currentOffset > offset) {\n        high = middle - 1;\n      }\n    }\n    if (low > 0) {\n      return low - 1;\n    }\n    return 0;\n  };\n  SizeAndPositionManager.prototype.exponentialSearch = function (_a) {\n    var index = _a.index,\n      offset = _a.offset;\n    var interval = 1;\n    while (index < this.itemCount && this.getSizeAndPositionForIndex(index).offset < offset) {\n      index += interval;\n      interval *= 2;\n    }\n    return this.binarySearch({\n      high: Math.min(index, this.itemCount - 1),\n      low: Math.floor(index / 2),\n      offset: offset\n    });\n  };\n  return SizeAndPositionManager;\n}();\nvar STYLE_WRAPPER = {\n  overflow: 'auto',\n  willChange: 'transform',\n  WebkitOverflowScrolling: 'touch'\n};\nvar STYLE_INNER = {\n  position: 'relative',\n  width: '100%',\n  minHeight: '100%'\n};\nvar STYLE_ITEM = {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  width: '100%'\n};\nvar STYLE_STICKY_ITEM = __assign({}, STYLE_ITEM, {\n  position: 'sticky'\n});\nvar VirtualList = /** @class */function (_super) {\n  __extends(VirtualList, _super);\n  function VirtualList() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.itemSizeGetter = function (itemSize) {\n      return function (index) {\n        return _this.getSize(index, itemSize);\n      };\n    };\n    _this.sizeAndPositionManager = new SizeAndPositionManager({\n      itemCount: _this.props.itemCount,\n      itemSizeGetter: _this.itemSizeGetter(_this.props.itemSize),\n      estimatedItemSize: _this.getEstimatedItemSize()\n    });\n    _this.state = {\n      offset: _this.props.scrollOffset || _this.props.scrollToIndex != null && _this.getOffsetForIndex(_this.props.scrollToIndex) || 0,\n      scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n    };\n    _this.styleCache = {};\n    _this.getRef = function (node) {\n      _this.rootNode = node;\n    };\n    _this.handleScroll = function (event) {\n      var onScroll = _this.props.onScroll;\n      var offset = _this.getNodeOffset();\n      if (offset < 0 || _this.state.offset === offset || event.target !== _this.rootNode) {\n        return;\n      }\n      _this.setState({\n        offset: offset,\n        scrollChangeReason: SCROLL_CHANGE_REASON.OBSERVED\n      });\n      if (typeof onScroll === 'function') {\n        onScroll(offset, event);\n      }\n    };\n    return _this;\n  }\n  VirtualList.prototype.componentDidMount = function () {\n    var _a = this.props,\n      scrollOffset = _a.scrollOffset,\n      scrollToIndex = _a.scrollToIndex;\n    this.rootNode.addEventListener('scroll', this.handleScroll, {\n      passive: true\n    });\n    if (scrollOffset != null) {\n      this.scrollTo(scrollOffset);\n    } else if (scrollToIndex != null) {\n      this.scrollTo(this.getOffsetForIndex(scrollToIndex));\n    }\n  };\n  VirtualList.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {\n    var _a = this.props,\n      estimatedItemSize = _a.estimatedItemSize,\n      itemCount = _a.itemCount,\n      itemSize = _a.itemSize,\n      scrollOffset = _a.scrollOffset,\n      scrollToAlignment = _a.scrollToAlignment,\n      scrollToIndex = _a.scrollToIndex;\n    var scrollPropsHaveChanged = nextProps.scrollToIndex !== scrollToIndex || nextProps.scrollToAlignment !== scrollToAlignment;\n    var itemPropsHaveChanged = nextProps.itemCount !== itemCount || nextProps.itemSize !== itemSize || nextProps.estimatedItemSize !== estimatedItemSize;\n    if (nextProps.itemSize !== itemSize) {\n      this.sizeAndPositionManager.updateConfig({\n        itemSizeGetter: this.itemSizeGetter(nextProps.itemSize)\n      });\n    }\n    if (nextProps.itemCount !== itemCount || nextProps.estimatedItemSize !== estimatedItemSize) {\n      this.sizeAndPositionManager.updateConfig({\n        itemCount: nextProps.itemCount,\n        estimatedItemSize: this.getEstimatedItemSize(nextProps)\n      });\n    }\n    if (itemPropsHaveChanged) {\n      this.recomputeSizes();\n    }\n    if (nextProps.scrollOffset !== scrollOffset) {\n      this.setState({\n        offset: nextProps.scrollOffset || 0,\n        scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n      });\n    } else if (typeof nextProps.scrollToIndex === 'number' && (scrollPropsHaveChanged || itemPropsHaveChanged)) {\n      this.setState({\n        offset: this.getOffsetForIndex(nextProps.scrollToIndex, nextProps.scrollToAlignment, nextProps.itemCount),\n        scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n      });\n    }\n  };\n  VirtualList.prototype.componentDidUpdate = function (_, prevState) {\n    var _a = this.state,\n      offset = _a.offset,\n      scrollChangeReason = _a.scrollChangeReason;\n    if (prevState.offset !== offset && scrollChangeReason === SCROLL_CHANGE_REASON.REQUESTED) {\n      this.scrollTo(offset);\n    }\n  };\n  VirtualList.prototype.componentWillUnmount = function () {\n    this.rootNode.removeEventListener('scroll', this.handleScroll);\n  };\n  VirtualList.prototype.scrollTo = function (value) {\n    var _a = this.props.scrollDirection,\n      scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n    this.rootNode[scrollProp[scrollDirection]] = value;\n  };\n  VirtualList.prototype.getOffsetForIndex = function (index, scrollToAlignment, itemCount) {\n    if (scrollToAlignment === void 0) {\n      scrollToAlignment = this.props.scrollToAlignment;\n    }\n    if (itemCount === void 0) {\n      itemCount = this.props.itemCount;\n    }\n    var _a = this.props.scrollDirection,\n      scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n    if (index < 0 || index >= itemCount) {\n      index = 0;\n    }\n    return this.sizeAndPositionManager.getUpdatedOffsetForIndex({\n      align: scrollToAlignment,\n      containerSize: this.props[sizeProp[scrollDirection]],\n      currentOffset: this.state && this.state.offset || 0,\n      targetIndex: index\n    });\n  };\n  VirtualList.prototype.recomputeSizes = function (startIndex) {\n    if (startIndex === void 0) {\n      startIndex = 0;\n    }\n    this.styleCache = {};\n    this.sizeAndPositionManager.resetItem(startIndex);\n  };\n  VirtualList.prototype.render = function () {\n    var _this = this;\n    var _a = this.props,\n      estimatedItemSize = _a.estimatedItemSize,\n      height = _a.height,\n      _b = _a.overscanCount,\n      overscanCount = _b === void 0 ? 3 : _b,\n      renderItem = _a.renderItem,\n      itemCount = _a.itemCount,\n      itemSize = _a.itemSize,\n      onItemsRendered = _a.onItemsRendered,\n      onScroll = _a.onScroll,\n      _c = _a.scrollDirection,\n      scrollDirection = _c === void 0 ? DIRECTION.VERTICAL : _c,\n      scrollOffset = _a.scrollOffset,\n      scrollToIndex = _a.scrollToIndex,\n      scrollToAlignment = _a.scrollToAlignment,\n      stickyIndices = _a.stickyIndices,\n      style = _a.style,\n      width = _a.width,\n      props = __rest(_a, [\"estimatedItemSize\", \"height\", \"overscanCount\", \"renderItem\", \"itemCount\", \"itemSize\", \"onItemsRendered\", \"onScroll\", \"scrollDirection\", \"scrollOffset\", \"scrollToIndex\", \"scrollToAlignment\", \"stickyIndices\", \"style\", \"width\"]);\n    var offset = this.state.offset;\n    var _d = this.sizeAndPositionManager.getVisibleRange({\n        containerSize: this.props[sizeProp[scrollDirection]] || 0,\n        offset: offset,\n        overscanCount: overscanCount\n      }),\n      start = _d.start,\n      stop = _d.stop;\n    var items = [];\n    var wrapperStyle = __assign({}, STYLE_WRAPPER, style, {\n      height: height,\n      width: width\n    });\n    var innerStyle = __assign({}, STYLE_INNER, (_e = {}, _e[sizeProp[scrollDirection]] = this.sizeAndPositionManager.getTotalSize(), _e));\n    if (stickyIndices != null && stickyIndices.length !== 0) {\n      stickyIndices.forEach(function (index) {\n        return items.push(renderItem({\n          index: index,\n          style: _this.getStyle(index, true)\n        }));\n      });\n      if (scrollDirection === DIRECTION.HORIZONTAL) {\n        innerStyle.display = 'flex';\n      }\n    }\n    if (typeof start !== 'undefined' && typeof stop !== 'undefined') {\n      for (var index = start; index <= stop; index++) {\n        if (stickyIndices != null && stickyIndices.includes(index)) {\n          continue;\n        }\n        items.push(renderItem({\n          index: index,\n          style: this.getStyle(index, false)\n        }));\n      }\n      if (typeof onItemsRendered === 'function') {\n        onItemsRendered({\n          startIndex: start,\n          stopIndex: stop\n        });\n      }\n    }\n    return createElement(\"div\", __assign({\n      ref: this.getRef\n    }, props, {\n      style: wrapperStyle\n    }), createElement(\"div\", {\n      style: innerStyle\n    }, items));\n    var _e;\n  };\n  VirtualList.prototype.getNodeOffset = function () {\n    var _a = this.props.scrollDirection,\n      scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n    return this.rootNode[scrollProp[scrollDirection]];\n  };\n  VirtualList.prototype.getEstimatedItemSize = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n    return props.estimatedItemSize || typeof props.itemSize === 'number' && props.itemSize || 50;\n  };\n  VirtualList.prototype.getSize = function (index, itemSize) {\n    if (typeof itemSize === 'function') {\n      return itemSize(index);\n    }\n    return Array.isArray(itemSize) ? itemSize[index] : itemSize;\n  };\n  VirtualList.prototype.getStyle = function (index, sticky) {\n    var style = this.styleCache[index];\n    if (style) {\n      return style;\n    }\n    var _a = this.props.scrollDirection,\n      scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n    var _b = this.sizeAndPositionManager.getSizeAndPositionForIndex(index),\n      size = _b.size,\n      offset = _b.offset;\n    return this.styleCache[index] = sticky ? __assign({}, STYLE_STICKY_ITEM, (_c = {}, _c[sizeProp[scrollDirection]] = size, _c[marginProp[scrollDirection]] = offset, _c[oppositeMarginProp[scrollDirection]] = -(offset + size), _c.zIndex = 1, _c)) : __assign({}, STYLE_ITEM, (_d = {}, _d[sizeProp[scrollDirection]] = size, _d[positionProp[scrollDirection]] = offset, _d));\n    var _c, _d;\n  };\n  VirtualList.defaultProps = {\n    overscanCount: 3,\n    scrollDirection: DIRECTION.VERTICAL,\n    width: '100%'\n  };\n  VirtualList.propTypes = {\n    estimatedItemSize: number,\n    height: oneOfType([number, string]).isRequired,\n    itemCount: number.isRequired,\n    itemSize: oneOfType([number, array, func]).isRequired,\n    onScroll: func,\n    onItemsRendered: func,\n    overscanCount: number,\n    renderItem: func.isRequired,\n    scrollOffset: number,\n    scrollToIndex: number,\n    scrollToAlignment: oneOf([ALIGNMENT.AUTO, ALIGNMENT.START, ALIGNMENT.CENTER, ALIGNMENT.END]),\n    scrollDirection: oneOf([DIRECTION.HORIZONTAL, DIRECTION.VERTICAL]),\n    stickyIndices: arrayOf(number),\n    style: object,\n    width: oneOfType([number, string])\n  };\n  return VirtualList;\n}(PureComponent);\nexport { DIRECTION as ScrollDirection };\nexport default VirtualList;","map":{"version":3,"names":["PureComponent","createElement","array","arrayOf","func","number","object","oneOf","oneOfType","string","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__rest","e","indexOf","getOwnPropertySymbols","ALIGNMENT","DIRECTION","SCROLL_CHANGE_REASON","scrollProp","_a","VERTICAL","HORIZONTAL","sizeProp","_b","positionProp","_c","marginProp","_d","oppositeMarginProp","_e","SizeAndPositionManager","itemCount","itemSizeGetter","estimatedItemSize","itemSizeAndPositionData","lastMeasuredIndex","updateConfig","getLastMeasuredIndex","getSizeAndPositionForIndex","index","Error","lastMeasuredSizeAndPosition","getSizeAndPositionOfLastMeasuredItem","offset","size","isNaN","getTotalSize","getUpdatedOffsetForIndex","align","START","containerSize","currentOffset","targetIndex","datum","maxOffset","minOffset","idealOffset","END","CENTER","Math","max","min","totalSize","getVisibleRange","overscanCount","start","findNearestItem","stop","resetItem","binarySearch","high","low","exponentialSearch","middle","floor","interval","STYLE_WRAPPER","overflow","willChange","WebkitOverflowScrolling","STYLE_INNER","position","width","minHeight","STYLE_ITEM","top","left","STYLE_STICKY_ITEM","VirtualList","_super","_this","itemSize","getSize","sizeAndPositionManager","props","getEstimatedItemSize","state","scrollOffset","scrollToIndex","getOffsetForIndex","scrollChangeReason","REQUESTED","styleCache","getRef","node","rootNode","handleScroll","event","onScroll","getNodeOffset","target","setState","OBSERVED","componentDidMount","addEventListener","passive","scrollTo","UNSAFE_componentWillReceiveProps","nextProps","scrollToAlignment","scrollPropsHaveChanged","itemPropsHaveChanged","recomputeSizes","componentDidUpdate","_","prevState","componentWillUnmount","removeEventListener","value","scrollDirection","startIndex","render","height","renderItem","onItemsRendered","stickyIndices","style","items","wrapperStyle","innerStyle","forEach","push","getStyle","display","includes","stopIndex","ref","isArray","sticky","zIndex","defaultProps","propTypes","isRequired","AUTO","ScrollDirection"],"sources":["D:/SPRING BOOT/reservation-salle/reservation-salle-front/node_modules/@segment/react-tiny-virtual-list/build/react-tiny-virtual-list.es.js"],"sourcesContent":["import { PureComponent, createElement } from 'react';\nimport { array, arrayOf, func, number, object, oneOf, oneOfType, string } from 'prop-types';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\n\nvar ALIGNMENT;\n(function (ALIGNMENT) {\n    ALIGNMENT[\"AUTO\"] = \"auto\";\n    ALIGNMENT[\"START\"] = \"start\";\n    ALIGNMENT[\"CENTER\"] = \"center\";\n    ALIGNMENT[\"END\"] = \"end\";\n})(ALIGNMENT || (ALIGNMENT = {}));\nvar DIRECTION;\n(function (DIRECTION) {\n    DIRECTION[\"HORIZONTAL\"] = \"horizontal\";\n    DIRECTION[\"VERTICAL\"] = \"vertical\";\n})(DIRECTION || (DIRECTION = {}));\nvar SCROLL_CHANGE_REASON;\n(function (SCROLL_CHANGE_REASON) {\n    SCROLL_CHANGE_REASON[\"OBSERVED\"] = \"observed\";\n    SCROLL_CHANGE_REASON[\"REQUESTED\"] = \"requested\";\n})(SCROLL_CHANGE_REASON || (SCROLL_CHANGE_REASON = {}));\nvar scrollProp = (_a = {}, _a[DIRECTION.VERTICAL] = 'scrollTop', _a[DIRECTION.HORIZONTAL] = 'scrollLeft', _a);\nvar sizeProp = (_b = {}, _b[DIRECTION.VERTICAL] = 'height', _b[DIRECTION.HORIZONTAL] = 'width', _b);\nvar positionProp = (_c = {}, _c[DIRECTION.VERTICAL] = 'top', _c[DIRECTION.HORIZONTAL] = 'left', _c);\nvar marginProp = (_d = {}, _d[DIRECTION.VERTICAL] = 'marginTop', _d[DIRECTION.HORIZONTAL] = 'marginLeft', _d);\nvar oppositeMarginProp = (_e = {}, _e[DIRECTION.VERTICAL] = 'marginBottom', _e[DIRECTION.HORIZONTAL] = 'marginRight', _e);\nvar _a;\nvar _b;\nvar _c;\nvar _d;\nvar _e;\n\n/* Forked from react-virtualized ðŸ’– */\nvar SizeAndPositionManager = /** @class */function () {\n    function SizeAndPositionManager(_a) {\n        var itemCount = _a.itemCount,\n            itemSizeGetter = _a.itemSizeGetter,\n            estimatedItemSize = _a.estimatedItemSize;\n        this.itemSizeGetter = itemSizeGetter;\n        this.itemCount = itemCount;\n        this.estimatedItemSize = estimatedItemSize;\n        // Cache of size and position data for items, mapped by item index.\n        this.itemSizeAndPositionData = {};\n        // Measurements for items up to this index can be trusted; items afterward should be estimated.\n        this.lastMeasuredIndex = -1;\n    }\n    SizeAndPositionManager.prototype.updateConfig = function (_a) {\n        var itemCount = _a.itemCount,\n            itemSizeGetter = _a.itemSizeGetter,\n            estimatedItemSize = _a.estimatedItemSize;\n        if (itemCount != null) {\n            this.itemCount = itemCount;\n        }\n        if (estimatedItemSize != null) {\n            this.estimatedItemSize = estimatedItemSize;\n        }\n        if (itemSizeGetter != null) {\n            this.itemSizeGetter = itemSizeGetter;\n        }\n    };\n    SizeAndPositionManager.prototype.getLastMeasuredIndex = function () {\n        return this.lastMeasuredIndex;\n    };\n    /**\n     * This method returns the size and position for the item at the specified index.\n     * It just-in-time calculates (or used cached values) for items leading up to the index.\n     */\n    SizeAndPositionManager.prototype.getSizeAndPositionForIndex = function (index) {\n        if (index < 0 || index >= this.itemCount) {\n            throw Error(\"Requested index \" + index + \" is outside of range 0..\" + this.itemCount);\n        }\n        if (index > this.lastMeasuredIndex) {\n            var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n            var offset = lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size;\n            for (var i = this.lastMeasuredIndex + 1; i <= index; i++) {\n                var size = this.itemSizeGetter(i);\n                if (size == null || isNaN(size)) {\n                    throw Error(\"Invalid size returned for index \" + i + \" of value \" + size);\n                }\n                this.itemSizeAndPositionData[i] = {\n                    offset: offset,\n                    size: size\n                };\n                offset += size;\n            }\n            this.lastMeasuredIndex = index;\n        }\n        return this.itemSizeAndPositionData[index];\n    };\n    SizeAndPositionManager.prototype.getSizeAndPositionOfLastMeasuredItem = function () {\n        return this.lastMeasuredIndex >= 0 ? this.itemSizeAndPositionData[this.lastMeasuredIndex] : { offset: 0, size: 0 };\n    };\n    /**\n     * Total size of all items being measured.\n     * This value will be completedly estimated initially.\n     * As items as measured the estimate will be updated.\n     */\n    SizeAndPositionManager.prototype.getTotalSize = function () {\n        var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n        return lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size + (this.itemCount - this.lastMeasuredIndex - 1) * this.estimatedItemSize;\n    };\n    /**\n     * Determines a new offset that ensures a certain item is visible, given the alignment.\n     *\n     * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\n     * @param containerSize Size (width or height) of the container viewport\n     * @return Offset to use to ensure the specified item is visible\n     */\n    SizeAndPositionManager.prototype.getUpdatedOffsetForIndex = function (_a) {\n        var _b = _a.align,\n            align = _b === void 0 ? ALIGNMENT.START : _b,\n            containerSize = _a.containerSize,\n            currentOffset = _a.currentOffset,\n            targetIndex = _a.targetIndex;\n        if (containerSize <= 0) {\n            return 0;\n        }\n        var datum = this.getSizeAndPositionForIndex(targetIndex);\n        var maxOffset = datum.offset;\n        var minOffset = maxOffset - containerSize + datum.size;\n        var idealOffset;\n        switch (align) {\n            case ALIGNMENT.END:\n                idealOffset = minOffset;\n                break;\n            case ALIGNMENT.CENTER:\n                idealOffset = maxOffset - (containerSize - datum.size) / 2;\n                break;\n            case ALIGNMENT.START:\n                idealOffset = maxOffset;\n                break;\n            default:\n                idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\n        }\n        var totalSize = this.getTotalSize();\n        return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n    };\n    SizeAndPositionManager.prototype.getVisibleRange = function (_a) {\n        var containerSize = _a.containerSize,\n            offset = _a.offset,\n            overscanCount = _a.overscanCount;\n        var totalSize = this.getTotalSize();\n        if (totalSize === 0) {\n            return {};\n        }\n        var maxOffset = offset + containerSize;\n        var start = this.findNearestItem(offset);\n        if (typeof start === 'undefined') {\n            throw Error(\"Invalid offset \" + offset + \" specified\");\n        }\n        var datum = this.getSizeAndPositionForIndex(start);\n        offset = datum.offset + datum.size;\n        var stop = start;\n        while (offset < maxOffset && stop < this.itemCount - 1) {\n            stop++;\n            offset += this.getSizeAndPositionForIndex(stop).size;\n        }\n        if (overscanCount) {\n            start = Math.max(0, start - overscanCount);\n            stop = Math.min(stop + overscanCount, this.itemCount - 1);\n        }\n        return {\n            start: start,\n            stop: stop\n        };\n    };\n    /**\n     * Clear all cached values for items after the specified index.\n     * This method should be called for any item that has changed its size.\n     * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\n     */\n    SizeAndPositionManager.prototype.resetItem = function (index) {\n        this.lastMeasuredIndex = Math.min(this.lastMeasuredIndex, index - 1);\n    };\n    /**\n     * Searches for the item (index) nearest the specified offset.\n     *\n     * If no exact match is found the next lowest item index will be returned.\n     * This allows partially visible items (with offsets just before/above the fold) to be visible.\n     */\n    SizeAndPositionManager.prototype.findNearestItem = function (offset) {\n        if (isNaN(offset)) {\n            throw Error(\"Invalid offset \" + offset + \" specified\");\n        }\n        // Our search algorithms find the nearest match at or below the specified offset.\n        // So make sure the offset is at least 0 or no match will be found.\n        offset = Math.max(0, offset);\n        var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n        var lastMeasuredIndex = Math.max(0, this.lastMeasuredIndex);\n        if (lastMeasuredSizeAndPosition.offset >= offset) {\n            // If we've already measured items within this range just use a binary search as it's faster.\n            return this.binarySearch({\n                high: lastMeasuredIndex,\n                low: 0,\n                offset: offset\n            });\n        } else {\n            // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n            // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n            // The overall complexity for this approach is O(log n).\n            return this.exponentialSearch({\n                index: lastMeasuredIndex,\n                offset: offset\n            });\n        }\n    };\n    SizeAndPositionManager.prototype.binarySearch = function (_a) {\n        var low = _a.low,\n            high = _a.high,\n            offset = _a.offset;\n        var middle = 0;\n        var currentOffset = 0;\n        while (low <= high) {\n            middle = low + Math.floor((high - low) / 2);\n            currentOffset = this.getSizeAndPositionForIndex(middle).offset;\n            if (currentOffset === offset) {\n                return middle;\n            } else if (currentOffset < offset) {\n                low = middle + 1;\n            } else if (currentOffset > offset) {\n                high = middle - 1;\n            }\n        }\n        if (low > 0) {\n            return low - 1;\n        }\n        return 0;\n    };\n    SizeAndPositionManager.prototype.exponentialSearch = function (_a) {\n        var index = _a.index,\n            offset = _a.offset;\n        var interval = 1;\n        while (index < this.itemCount && this.getSizeAndPositionForIndex(index).offset < offset) {\n            index += interval;\n            interval *= 2;\n        }\n        return this.binarySearch({\n            high: Math.min(index, this.itemCount - 1),\n            low: Math.floor(index / 2),\n            offset: offset\n        });\n    };\n    return SizeAndPositionManager;\n}();\n\nvar STYLE_WRAPPER = {\n    overflow: 'auto',\n    willChange: 'transform',\n    WebkitOverflowScrolling: 'touch'\n};\nvar STYLE_INNER = {\n    position: 'relative',\n    width: '100%',\n    minHeight: '100%'\n};\nvar STYLE_ITEM = {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%'\n};\nvar STYLE_STICKY_ITEM = __assign({}, STYLE_ITEM, { position: 'sticky' });\nvar VirtualList = /** @class */function (_super) {\n    __extends(VirtualList, _super);\n    function VirtualList() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.itemSizeGetter = function (itemSize) {\n            return function (index) {\n                return _this.getSize(index, itemSize);\n            };\n        };\n        _this.sizeAndPositionManager = new SizeAndPositionManager({\n            itemCount: _this.props.itemCount,\n            itemSizeGetter: _this.itemSizeGetter(_this.props.itemSize),\n            estimatedItemSize: _this.getEstimatedItemSize()\n        });\n        _this.state = {\n            offset: _this.props.scrollOffset || _this.props.scrollToIndex != null && _this.getOffsetForIndex(_this.props.scrollToIndex) || 0,\n            scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n        };\n        _this.styleCache = {};\n        _this.getRef = function (node) {\n            _this.rootNode = node;\n        };\n        _this.handleScroll = function (event) {\n            var onScroll = _this.props.onScroll;\n            var offset = _this.getNodeOffset();\n            if (offset < 0 || _this.state.offset === offset || event.target !== _this.rootNode) {\n                return;\n            }\n            _this.setState({\n                offset: offset,\n                scrollChangeReason: SCROLL_CHANGE_REASON.OBSERVED\n            });\n            if (typeof onScroll === 'function') {\n                onScroll(offset, event);\n            }\n        };\n        return _this;\n    }\n    VirtualList.prototype.componentDidMount = function () {\n        var _a = this.props,\n            scrollOffset = _a.scrollOffset,\n            scrollToIndex = _a.scrollToIndex;\n        this.rootNode.addEventListener('scroll', this.handleScroll, {\n            passive: true\n        });\n        if (scrollOffset != null) {\n            this.scrollTo(scrollOffset);\n        } else if (scrollToIndex != null) {\n            this.scrollTo(this.getOffsetForIndex(scrollToIndex));\n        }\n    };\n    VirtualList.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {\n        var _a = this.props,\n            estimatedItemSize = _a.estimatedItemSize,\n            itemCount = _a.itemCount,\n            itemSize = _a.itemSize,\n            scrollOffset = _a.scrollOffset,\n            scrollToAlignment = _a.scrollToAlignment,\n            scrollToIndex = _a.scrollToIndex;\n        var scrollPropsHaveChanged = nextProps.scrollToIndex !== scrollToIndex || nextProps.scrollToAlignment !== scrollToAlignment;\n        var itemPropsHaveChanged = nextProps.itemCount !== itemCount || nextProps.itemSize !== itemSize || nextProps.estimatedItemSize !== estimatedItemSize;\n        if (nextProps.itemSize !== itemSize) {\n            this.sizeAndPositionManager.updateConfig({\n                itemSizeGetter: this.itemSizeGetter(nextProps.itemSize)\n            });\n        }\n        if (nextProps.itemCount !== itemCount || nextProps.estimatedItemSize !== estimatedItemSize) {\n            this.sizeAndPositionManager.updateConfig({\n                itemCount: nextProps.itemCount,\n                estimatedItemSize: this.getEstimatedItemSize(nextProps)\n            });\n        }\n        if (itemPropsHaveChanged) {\n            this.recomputeSizes();\n        }\n        if (nextProps.scrollOffset !== scrollOffset) {\n            this.setState({\n                offset: nextProps.scrollOffset || 0,\n                scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n            });\n        } else if (typeof nextProps.scrollToIndex === 'number' && (scrollPropsHaveChanged || itemPropsHaveChanged)) {\n            this.setState({\n                offset: this.getOffsetForIndex(nextProps.scrollToIndex, nextProps.scrollToAlignment, nextProps.itemCount),\n                scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n            });\n        }\n    };\n    VirtualList.prototype.componentDidUpdate = function (_, prevState) {\n        var _a = this.state,\n            offset = _a.offset,\n            scrollChangeReason = _a.scrollChangeReason;\n        if (prevState.offset !== offset && scrollChangeReason === SCROLL_CHANGE_REASON.REQUESTED) {\n            this.scrollTo(offset);\n        }\n    };\n    VirtualList.prototype.componentWillUnmount = function () {\n        this.rootNode.removeEventListener('scroll', this.handleScroll);\n    };\n    VirtualList.prototype.scrollTo = function (value) {\n        var _a = this.props.scrollDirection,\n            scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n        this.rootNode[scrollProp[scrollDirection]] = value;\n    };\n    VirtualList.prototype.getOffsetForIndex = function (index, scrollToAlignment, itemCount) {\n        if (scrollToAlignment === void 0) {\n            scrollToAlignment = this.props.scrollToAlignment;\n        }\n        if (itemCount === void 0) {\n            itemCount = this.props.itemCount;\n        }\n        var _a = this.props.scrollDirection,\n            scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n        if (index < 0 || index >= itemCount) {\n            index = 0;\n        }\n        return this.sizeAndPositionManager.getUpdatedOffsetForIndex({\n            align: scrollToAlignment,\n            containerSize: this.props[sizeProp[scrollDirection]],\n            currentOffset: this.state && this.state.offset || 0,\n            targetIndex: index\n        });\n    };\n    VirtualList.prototype.recomputeSizes = function (startIndex) {\n        if (startIndex === void 0) {\n            startIndex = 0;\n        }\n        this.styleCache = {};\n        this.sizeAndPositionManager.resetItem(startIndex);\n    };\n    VirtualList.prototype.render = function () {\n        var _this = this;\n        var _a = this.props,\n            estimatedItemSize = _a.estimatedItemSize,\n            height = _a.height,\n            _b = _a.overscanCount,\n            overscanCount = _b === void 0 ? 3 : _b,\n            renderItem = _a.renderItem,\n            itemCount = _a.itemCount,\n            itemSize = _a.itemSize,\n            onItemsRendered = _a.onItemsRendered,\n            onScroll = _a.onScroll,\n            _c = _a.scrollDirection,\n            scrollDirection = _c === void 0 ? DIRECTION.VERTICAL : _c,\n            scrollOffset = _a.scrollOffset,\n            scrollToIndex = _a.scrollToIndex,\n            scrollToAlignment = _a.scrollToAlignment,\n            stickyIndices = _a.stickyIndices,\n            style = _a.style,\n            width = _a.width,\n            props = __rest(_a, [\"estimatedItemSize\", \"height\", \"overscanCount\", \"renderItem\", \"itemCount\", \"itemSize\", \"onItemsRendered\", \"onScroll\", \"scrollDirection\", \"scrollOffset\", \"scrollToIndex\", \"scrollToAlignment\", \"stickyIndices\", \"style\", \"width\"]);\n        var offset = this.state.offset;\n        var _d = this.sizeAndPositionManager.getVisibleRange({\n            containerSize: this.props[sizeProp[scrollDirection]] || 0,\n            offset: offset,\n            overscanCount: overscanCount\n        }),\n            start = _d.start,\n            stop = _d.stop;\n        var items = [];\n        var wrapperStyle = __assign({}, STYLE_WRAPPER, style, { height: height, width: width });\n        var innerStyle = __assign({}, STYLE_INNER, (_e = {}, _e[sizeProp[scrollDirection]] = this.sizeAndPositionManager.getTotalSize(), _e));\n        if (stickyIndices != null && stickyIndices.length !== 0) {\n            stickyIndices.forEach(function (index) {\n                return items.push(renderItem({\n                    index: index,\n                    style: _this.getStyle(index, true)\n                }));\n            });\n            if (scrollDirection === DIRECTION.HORIZONTAL) {\n                innerStyle.display = 'flex';\n            }\n        }\n        if (typeof start !== 'undefined' && typeof stop !== 'undefined') {\n            for (var index = start; index <= stop; index++) {\n                if (stickyIndices != null && stickyIndices.includes(index)) {\n                    continue;\n                }\n                items.push(renderItem({\n                    index: index,\n                    style: this.getStyle(index, false)\n                }));\n            }\n            if (typeof onItemsRendered === 'function') {\n                onItemsRendered({\n                    startIndex: start,\n                    stopIndex: stop\n                });\n            }\n        }\n        return createElement(\"div\", __assign({ ref: this.getRef }, props, { style: wrapperStyle }), createElement(\"div\", { style: innerStyle }, items));\n        var _e;\n    };\n    VirtualList.prototype.getNodeOffset = function () {\n        var _a = this.props.scrollDirection,\n            scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n        return this.rootNode[scrollProp[scrollDirection]];\n    };\n    VirtualList.prototype.getEstimatedItemSize = function (props) {\n        if (props === void 0) {\n            props = this.props;\n        }\n        return props.estimatedItemSize || typeof props.itemSize === 'number' && props.itemSize || 50;\n    };\n    VirtualList.prototype.getSize = function (index, itemSize) {\n        if (typeof itemSize === 'function') {\n            return itemSize(index);\n        }\n        return Array.isArray(itemSize) ? itemSize[index] : itemSize;\n    };\n    VirtualList.prototype.getStyle = function (index, sticky) {\n        var style = this.styleCache[index];\n        if (style) {\n            return style;\n        }\n        var _a = this.props.scrollDirection,\n            scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n        var _b = this.sizeAndPositionManager.getSizeAndPositionForIndex(index),\n            size = _b.size,\n            offset = _b.offset;\n        return this.styleCache[index] = sticky ? __assign({}, STYLE_STICKY_ITEM, (_c = {}, _c[sizeProp[scrollDirection]] = size, _c[marginProp[scrollDirection]] = offset, _c[oppositeMarginProp[scrollDirection]] = -(offset + size), _c.zIndex = 1, _c)) : __assign({}, STYLE_ITEM, (_d = {}, _d[sizeProp[scrollDirection]] = size, _d[positionProp[scrollDirection]] = offset, _d));\n        var _c, _d;\n    };\n    VirtualList.defaultProps = {\n        overscanCount: 3,\n        scrollDirection: DIRECTION.VERTICAL,\n        width: '100%'\n    };\n    VirtualList.propTypes = {\n        estimatedItemSize: number,\n        height: oneOfType([number, string]).isRequired,\n        itemCount: number.isRequired,\n        itemSize: oneOfType([number, array, func]).isRequired,\n        onScroll: func,\n        onItemsRendered: func,\n        overscanCount: number,\n        renderItem: func.isRequired,\n        scrollOffset: number,\n        scrollToIndex: number,\n        scrollToAlignment: oneOf([ALIGNMENT.AUTO, ALIGNMENT.START, ALIGNMENT.CENTER, ALIGNMENT.END]),\n        scrollDirection: oneOf([DIRECTION.HORIZONTAL, DIRECTION.VERTICAL]),\n        stickyIndices: arrayOf(number),\n        style: object,\n        width: oneOfType([number, string])\n    };\n    return VirtualList;\n}(PureComponent);\n\nexport { DIRECTION as ScrollDirection };\nexport default VirtualList;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}