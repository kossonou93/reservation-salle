{"ast":null,"code":"import { Position } from '../../constants';\n/**\n * Function to create a Rect.\n * @param {Object} dimensions\n * @param {Number} dimensions.width\n * @param {Number} dimensions.height\n * @param {Object} position\n * @param {Number} position.left\n * @param {Number} position.top\n * @return {Object} Rect { width, height, left, top, right, bottom }\n */\n\nvar makeRect = function makeRect(_ref, _ref2) {\n  var height = _ref.height,\n    width = _ref.width;\n  var left = _ref2.left,\n    top = _ref2.top;\n  var ceiledLeft = Math.ceil(left);\n  var ceiledTop = Math.ceil(top);\n  return {\n    width: width,\n    height: height,\n    left: ceiledLeft,\n    top: ceiledTop,\n    right: ceiledLeft + width,\n    bottom: ceiledTop + height\n  };\n};\n/**\n * Function to flip a position upside down.\n * @param {Position} position\n * @return {Position} flipped position\n */\n\nvar flipHorizontal = function flipHorizontal(position) {\n  switch (position) {\n    case Position.TOP_LEFT:\n      return Position.BOTTOM_LEFT;\n    case Position.TOP:\n    default:\n      return Position.BOTTOM;\n    case Position.TOP_RIGHT:\n      return Position.BOTTOM_RIGHT;\n    case Position.BOTTOM_LEFT:\n      return Position.TOP_LEFT;\n    case Position.BOTTOM:\n      return Position.TOP;\n    case Position.BOTTOM_RIGHT:\n      return Position.TOP_RIGHT;\n  }\n};\n/**\n * Function that returns if position is aligned on top.\n * @param {Position} position\n * @return {Boolean}\n */\n\nvar isAlignedOnTop = function isAlignedOnTop(position) {\n  switch (position) {\n    case Position.TOP_LEFT:\n    case Position.TOP:\n    case Position.TOP_RIGHT:\n      return true;\n    default:\n      return false;\n  }\n};\n/**\n * Function that returns if position is aligned left or right.\n * @param {Position} position\n * @return {Boolean}\n */\n\nvar isAlignedHorizontal = function isAlignedHorizontal(position) {\n  switch (position) {\n    case Position.LEFT:\n    case Position.RIGHT:\n      return true;\n    default:\n      return false;\n  }\n};\n/**\n * Function that returns if a rect fits on bottom.\n * @param {Rect} rect\n * @param {Object} viewport\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\nvar getFitsOnBottom = function getFitsOnBottom(rect, viewport, viewportOffset) {\n  return rect.bottom < viewport.height - viewportOffset;\n};\n/**\n * Function that returns if a rect fits on top.\n * @param {Rect} rect\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\nvar getFitsOnTop = function getFitsOnTop(rect, viewportOffset) {\n  return rect.top > viewportOffset;\n};\n/**\n * Function that returns if a rect fits on right.\n * @param {Rect} rect\n * @param {Object} viewport\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\nvar getFitsOnRight = function getFitsOnRight(rect, viewport, viewportOffset) {\n  return rect.right < viewport.width - viewportOffset;\n};\n/**\n * Function that returns if a rect fits on left.\n * @param {Rect} rect\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\nvar getFitsOnLeft = function getFitsOnLeft(rect, viewportOffset) {\n  return rect.left > viewportOffset;\n};\n/**\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin\n * Function that returns the CSS `tranform-origin` property.\n * @param {Rect} rect\n * @param {Position} position\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Number} targetCenter - center of the target.\n * @return {String} transform origin\n */\n\nvar getTransformOrigin = function getTransformOrigin(_ref3) {\n  var dimensions = _ref3.dimensions,\n    position = _ref3.position,\n    rect = _ref3.rect,\n    targetCenter = _ref3.targetCenter;\n  var centerY = Math.round(targetCenter - rect.top);\n  if (position === Position.LEFT) {\n    /* Syntax: x-offset | y-offset */\n    return \"\".concat(dimensions.width, \"px \").concat(centerY, \"px\");\n  }\n  if (position === Position.RIGHT) {\n    /* Syntax: x-offset | y-offset */\n    return \"0px \".concat(centerY, \"px\");\n  }\n  var centerX = Math.round(targetCenter - rect.left);\n  if (isAlignedOnTop(position)) {\n    /* Syntax: x-offset | y-offset */\n    return \"\".concat(centerX, \"px \").concat(dimensions.height, \"px \");\n  }\n  /* Syntax: x-offset | y-offset */\n\n  return \"\".concat(centerX, \"px 0px \");\n};\n/**\n * Function that takes in numbers and position and gives the final coords.\n * @param {Object} input\n * @param {Position} input.position — the position the positioner should be on.\n * @param {Object} input.dimensions — the dimensions of the positioner.\n * @param {Object} input.targetRect — the rect of the target.\n * @param {Number} input.targetOffset - offset from the target.\n * @param {Object} input.viewport - the width and height of the viewport.\n * @param {Number} input.viewportOffset - offset from the viewport.\n * @return {Object} - { rect: Rect, position: Position, transformOrigin: string }\n */\n\nexport default function getFittedPosition(_ref4) {\n  var dimensions = _ref4.dimensions,\n    position = _ref4.position,\n    targetOffset = _ref4.targetOffset,\n    targetRect = _ref4.targetRect,\n    viewport = _ref4.viewport,\n    _ref4$viewportOffset = _ref4.viewportOffset,\n    viewportOffset = _ref4$viewportOffset === void 0 ? 8 : _ref4$viewportOffset;\n  var _getPosition = getPosition({\n      position: position,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset,\n      viewport: viewport,\n      viewportOffset: viewportOffset\n    }),\n    finalPosition = _getPosition.position,\n    rect = _getPosition.rect; // Push rect to the right if overflowing on the left side of the viewport.\n\n  if (rect.left < viewportOffset) {\n    rect.right += Math.ceil(Math.abs(rect.left - viewportOffset));\n    rect.left = Math.ceil(viewportOffset);\n  } // Push rect to the left if overflowing on the right side of the viewport.\n\n  if (rect.right > viewport.width - viewportOffset) {\n    var delta = Math.ceil(rect.right - (viewport.width - viewportOffset));\n    rect.left -= delta;\n    rect.right -= delta;\n  } // Push rect down if overflowing on the top side of the viewport.\n\n  if (rect.top < viewportOffset) {\n    rect.top += Math.ceil(Math.abs(rect.top - viewportOffset));\n    rect.bottom = Math.ceil(viewportOffset);\n  } // Push rect up if overflowing on the bottom side of the viewport.\n\n  if (rect.bottom > viewport.height - viewportOffset) {\n    var _delta = Math.ceil(rect.bottom - (viewport.height - viewportOffset));\n    rect.top -= _delta;\n    rect.bottom -= _delta;\n  }\n  var targetCenter = isAlignedHorizontal(position) ? targetRect.top + targetRect.height / 2 : targetRect.left + targetRect.width / 2;\n  var transformOrigin = getTransformOrigin({\n    rect: rect,\n    position: finalPosition,\n    dimensions: dimensions,\n    targetCenter: targetCenter\n  });\n  return {\n    rect: rect,\n    position: finalPosition,\n    transformOrigin: transformOrigin\n  };\n}\n/**\n * Function that takes in numbers and position and gives the final coords.\n * @param {Position} position — the position the positioner should be on.\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Rect} targetRect — the rect of the target.\n * @param {Number} targetOffset - offset from the target.\n * @param {Object} viewport - the width and height of the viewport.\n * @param {Object} viewportOffset - offset from the viewport.\n * @return {Object} - { rect: Rect, position: Position }\n */\n\nfunction getPosition(_ref5) {\n  var dimensions = _ref5.dimensions,\n    position = _ref5.position,\n    targetOffset = _ref5.targetOffset,\n    targetRect = _ref5.targetRect,\n    viewport = _ref5.viewport,\n    _ref5$viewportOffset = _ref5.viewportOffset,\n    viewportOffset = _ref5$viewportOffset === void 0 ? 8 : _ref5$viewportOffset;\n  var isHorizontal = isAlignedHorizontal(position); // Handle left and right positions\n\n  if (isHorizontal) {\n    var leftRect = getRect({\n      position: Position.LEFT,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    var rightRect = getRect({\n      position: Position.RIGHT,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    var fitsOnLeft = getFitsOnLeft(leftRect, viewportOffset);\n    var fitsOnRight = getFitsOnRight(rightRect, viewport, viewportOffset);\n    if (position === Position.LEFT) {\n      if (fitsOnLeft) {\n        return {\n          position: position,\n          rect: leftRect\n        };\n      }\n      if (fitsOnRight) {\n        return {\n          position: Position.RIGHT,\n          rect: rightRect\n        };\n      }\n    }\n    if (position === Position.RIGHT) {\n      if (fitsOnRight) {\n        return {\n          position: position,\n          rect: rightRect\n        };\n      }\n      if (fitsOnLeft) {\n        return {\n          position: Position.LEFT,\n          rect: leftRect\n        };\n      }\n    } // Default to using the position with the most space\n\n    var spaceRight = Math.abs(viewport.width - viewportOffset - rightRect.right);\n    var spaceLeft = Math.abs(leftRect.left - viewportOffset);\n    if (spaceRight < spaceLeft) {\n      return {\n        position: Position.RIGHT,\n        rect: rightRect\n      };\n    }\n    return {\n      position: Position.LEFT,\n      rect: leftRect\n    };\n  }\n  var positionIsAlignedOnTop = isAlignedOnTop(position);\n  var topRect;\n  var bottomRect;\n  if (positionIsAlignedOnTop) {\n    topRect = getRect({\n      position: position,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    bottomRect = getRect({\n      position: flipHorizontal(position),\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n  } else {\n    topRect = getRect({\n      position: flipHorizontal(position),\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    bottomRect = getRect({\n      position: position,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n  }\n  var topRectFitsOnTop = getFitsOnTop(topRect, viewportOffset);\n  var bottomRectFitsOnBottom = getFitsOnBottom(bottomRect, viewport, viewportOffset);\n  if (positionIsAlignedOnTop) {\n    if (topRectFitsOnTop) {\n      return {\n        position: position,\n        rect: topRect\n      };\n    }\n    if (bottomRectFitsOnBottom) {\n      return {\n        position: flipHorizontal(position),\n        rect: bottomRect\n      };\n    }\n  }\n  if (!positionIsAlignedOnTop) {\n    if (bottomRectFitsOnBottom) {\n      return {\n        position: position,\n        rect: bottomRect\n      };\n    }\n    if (topRectFitsOnTop) {\n      return {\n        position: flipHorizontal(position),\n        rect: topRect\n      };\n    }\n  } // Default to most spacious if there is no fit.\n\n  var spaceBottom = Math.abs(viewport.height - viewportOffset - bottomRect.bottom);\n  var spaceTop = Math.abs(topRect.top - viewportOffset);\n  if (spaceBottom < spaceTop) {\n    return {\n      position: positionIsAlignedOnTop ? flipHorizontal(position) : position,\n      rect: bottomRect\n    };\n  }\n  return {\n    position: positionIsAlignedOnTop ? position : flipHorizontal(position),\n    rect: topRect\n  };\n}\n/**\n * Function that takes in numbers and position and gives the final coords.\n * @param {Position} position\n * @param {Number} targetOffset - offset from the target.\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Rect} targetRect — the rect of the target.\n * @return {Rect} - Rect { width, height, left, top, right, bottom }\n */\n\nfunction getRect(_ref6) {\n  var dimensions = _ref6.dimensions,\n    position = _ref6.position,\n    targetOffset = _ref6.targetOffset,\n    targetRect = _ref6.targetRect;\n  var leftRect = targetRect.left + targetRect.width / 2 - dimensions.width / 2;\n  var alignedTopY = targetRect.top - dimensions.height - targetOffset;\n  var alignedBottomY = targetRect.bottom + targetOffset;\n  var alignedRightX = targetRect.right - dimensions.width;\n  var alignedLeftRightY = targetRect.top + targetRect.height / 2 - dimensions.height / 2;\n  switch (position) {\n    case Position.LEFT:\n      return makeRect(dimensions, {\n        left: targetRect.left - dimensions.width - targetOffset,\n        top: alignedLeftRightY\n      });\n    case Position.RIGHT:\n      return makeRect(dimensions, {\n        left: targetRect.right + targetOffset,\n        top: alignedLeftRightY\n      });\n    case Position.TOP:\n      return makeRect(dimensions, {\n        left: leftRect,\n        top: alignedTopY\n      });\n    case Position.TOP_LEFT:\n      return makeRect(dimensions, {\n        left: targetRect.left,\n        top: alignedTopY\n      });\n    case Position.TOP_RIGHT:\n      return makeRect(dimensions, {\n        left: alignedRightX,\n        top: alignedTopY\n      });\n    default:\n    case Position.BOTTOM:\n      return makeRect(dimensions, {\n        left: leftRect,\n        top: alignedBottomY\n      });\n    case Position.BOTTOM_LEFT:\n      return makeRect(dimensions, {\n        left: targetRect.left,\n        top: alignedBottomY\n      });\n    case Position.BOTTOM_RIGHT:\n      return makeRect(dimensions, {\n        left: alignedRightX,\n        top: alignedBottomY\n      });\n  }\n}","map":{"version":3,"names":["Position","makeRect","_ref","_ref2","height","width","left","top","ceiledLeft","Math","ceil","ceiledTop","right","bottom","flipHorizontal","position","TOP_LEFT","BOTTOM_LEFT","TOP","BOTTOM","TOP_RIGHT","BOTTOM_RIGHT","isAlignedOnTop","isAlignedHorizontal","LEFT","RIGHT","getFitsOnBottom","rect","viewport","viewportOffset","getFitsOnTop","getFitsOnRight","getFitsOnLeft","getTransformOrigin","_ref3","dimensions","targetCenter","centerY","round","concat","centerX","getFittedPosition","_ref4","targetOffset","targetRect","_ref4$viewportOffset","_getPosition","getPosition","finalPosition","abs","delta","_delta","transformOrigin","_ref5","_ref5$viewportOffset","isHorizontal","leftRect","getRect","rightRect","fitsOnLeft","fitsOnRight","spaceRight","spaceLeft","positionIsAlignedOnTop","topRect","bottomRect","topRectFitsOnTop","bottomRectFitsOnBottom","spaceBottom","spaceTop","_ref6","alignedTopY","alignedBottomY","alignedRightX","alignedLeftRightY"],"sources":["D:/SPRING BOOT/reservation-salle/reservation-salle-front/node_modules/evergreen-ui/esm/positioner/src/getPosition.js"],"sourcesContent":["import { Position } from '../../constants';\n/**\n * Function to create a Rect.\n * @param {Object} dimensions\n * @param {Number} dimensions.width\n * @param {Number} dimensions.height\n * @param {Object} position\n * @param {Number} position.left\n * @param {Number} position.top\n * @return {Object} Rect { width, height, left, top, right, bottom }\n */\n\nvar makeRect = function makeRect(_ref, _ref2) {\n  var height = _ref.height,\n      width = _ref.width;\n  var left = _ref2.left,\n      top = _ref2.top;\n  var ceiledLeft = Math.ceil(left);\n  var ceiledTop = Math.ceil(top);\n  return {\n    width: width,\n    height: height,\n    left: ceiledLeft,\n    top: ceiledTop,\n    right: ceiledLeft + width,\n    bottom: ceiledTop + height\n  };\n};\n/**\n * Function to flip a position upside down.\n * @param {Position} position\n * @return {Position} flipped position\n */\n\n\nvar flipHorizontal = function flipHorizontal(position) {\n  switch (position) {\n    case Position.TOP_LEFT:\n      return Position.BOTTOM_LEFT;\n\n    case Position.TOP:\n    default:\n      return Position.BOTTOM;\n\n    case Position.TOP_RIGHT:\n      return Position.BOTTOM_RIGHT;\n\n    case Position.BOTTOM_LEFT:\n      return Position.TOP_LEFT;\n\n    case Position.BOTTOM:\n      return Position.TOP;\n\n    case Position.BOTTOM_RIGHT:\n      return Position.TOP_RIGHT;\n  }\n};\n/**\n * Function that returns if position is aligned on top.\n * @param {Position} position\n * @return {Boolean}\n */\n\n\nvar isAlignedOnTop = function isAlignedOnTop(position) {\n  switch (position) {\n    case Position.TOP_LEFT:\n    case Position.TOP:\n    case Position.TOP_RIGHT:\n      return true;\n\n    default:\n      return false;\n  }\n};\n/**\n * Function that returns if position is aligned left or right.\n * @param {Position} position\n * @return {Boolean}\n */\n\n\nvar isAlignedHorizontal = function isAlignedHorizontal(position) {\n  switch (position) {\n    case Position.LEFT:\n    case Position.RIGHT:\n      return true;\n\n    default:\n      return false;\n  }\n};\n/**\n * Function that returns if a rect fits on bottom.\n * @param {Rect} rect\n * @param {Object} viewport\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\n\nvar getFitsOnBottom = function getFitsOnBottom(rect, viewport, viewportOffset) {\n  return rect.bottom < viewport.height - viewportOffset;\n};\n/**\n * Function that returns if a rect fits on top.\n * @param {Rect} rect\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\n\nvar getFitsOnTop = function getFitsOnTop(rect, viewportOffset) {\n  return rect.top > viewportOffset;\n};\n/**\n * Function that returns if a rect fits on right.\n * @param {Rect} rect\n * @param {Object} viewport\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\n\nvar getFitsOnRight = function getFitsOnRight(rect, viewport, viewportOffset) {\n  return rect.right < viewport.width - viewportOffset;\n};\n/**\n * Function that returns if a rect fits on left.\n * @param {Rect} rect\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\n\nvar getFitsOnLeft = function getFitsOnLeft(rect, viewportOffset) {\n  return rect.left > viewportOffset;\n};\n/**\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin\n * Function that returns the CSS `tranform-origin` property.\n * @param {Rect} rect\n * @param {Position} position\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Number} targetCenter - center of the target.\n * @return {String} transform origin\n */\n\n\nvar getTransformOrigin = function getTransformOrigin(_ref3) {\n  var dimensions = _ref3.dimensions,\n      position = _ref3.position,\n      rect = _ref3.rect,\n      targetCenter = _ref3.targetCenter;\n  var centerY = Math.round(targetCenter - rect.top);\n\n  if (position === Position.LEFT) {\n    /* Syntax: x-offset | y-offset */\n    return \"\".concat(dimensions.width, \"px \").concat(centerY, \"px\");\n  }\n\n  if (position === Position.RIGHT) {\n    /* Syntax: x-offset | y-offset */\n    return \"0px \".concat(centerY, \"px\");\n  }\n\n  var centerX = Math.round(targetCenter - rect.left);\n\n  if (isAlignedOnTop(position)) {\n    /* Syntax: x-offset | y-offset */\n    return \"\".concat(centerX, \"px \").concat(dimensions.height, \"px \");\n  }\n  /* Syntax: x-offset | y-offset */\n\n\n  return \"\".concat(centerX, \"px 0px \");\n};\n/**\n * Function that takes in numbers and position and gives the final coords.\n * @param {Object} input\n * @param {Position} input.position — the position the positioner should be on.\n * @param {Object} input.dimensions — the dimensions of the positioner.\n * @param {Object} input.targetRect — the rect of the target.\n * @param {Number} input.targetOffset - offset from the target.\n * @param {Object} input.viewport - the width and height of the viewport.\n * @param {Number} input.viewportOffset - offset from the viewport.\n * @return {Object} - { rect: Rect, position: Position, transformOrigin: string }\n */\n\n\nexport default function getFittedPosition(_ref4) {\n  var dimensions = _ref4.dimensions,\n      position = _ref4.position,\n      targetOffset = _ref4.targetOffset,\n      targetRect = _ref4.targetRect,\n      viewport = _ref4.viewport,\n      _ref4$viewportOffset = _ref4.viewportOffset,\n      viewportOffset = _ref4$viewportOffset === void 0 ? 8 : _ref4$viewportOffset;\n\n  var _getPosition = getPosition({\n    position: position,\n    dimensions: dimensions,\n    targetRect: targetRect,\n    targetOffset: targetOffset,\n    viewport: viewport,\n    viewportOffset: viewportOffset\n  }),\n      finalPosition = _getPosition.position,\n      rect = _getPosition.rect; // Push rect to the right if overflowing on the left side of the viewport.\n\n\n  if (rect.left < viewportOffset) {\n    rect.right += Math.ceil(Math.abs(rect.left - viewportOffset));\n    rect.left = Math.ceil(viewportOffset);\n  } // Push rect to the left if overflowing on the right side of the viewport.\n\n\n  if (rect.right > viewport.width - viewportOffset) {\n    var delta = Math.ceil(rect.right - (viewport.width - viewportOffset));\n    rect.left -= delta;\n    rect.right -= delta;\n  } // Push rect down if overflowing on the top side of the viewport.\n\n\n  if (rect.top < viewportOffset) {\n    rect.top += Math.ceil(Math.abs(rect.top - viewportOffset));\n    rect.bottom = Math.ceil(viewportOffset);\n  } // Push rect up if overflowing on the bottom side of the viewport.\n\n\n  if (rect.bottom > viewport.height - viewportOffset) {\n    var _delta = Math.ceil(rect.bottom - (viewport.height - viewportOffset));\n\n    rect.top -= _delta;\n    rect.bottom -= _delta;\n  }\n\n  var targetCenter = isAlignedHorizontal(position) ? targetRect.top + targetRect.height / 2 : targetRect.left + targetRect.width / 2;\n  var transformOrigin = getTransformOrigin({\n    rect: rect,\n    position: finalPosition,\n    dimensions: dimensions,\n    targetCenter: targetCenter\n  });\n  return {\n    rect: rect,\n    position: finalPosition,\n    transformOrigin: transformOrigin\n  };\n}\n/**\n * Function that takes in numbers and position and gives the final coords.\n * @param {Position} position — the position the positioner should be on.\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Rect} targetRect — the rect of the target.\n * @param {Number} targetOffset - offset from the target.\n * @param {Object} viewport - the width and height of the viewport.\n * @param {Object} viewportOffset - offset from the viewport.\n * @return {Object} - { rect: Rect, position: Position }\n */\n\nfunction getPosition(_ref5) {\n  var dimensions = _ref5.dimensions,\n      position = _ref5.position,\n      targetOffset = _ref5.targetOffset,\n      targetRect = _ref5.targetRect,\n      viewport = _ref5.viewport,\n      _ref5$viewportOffset = _ref5.viewportOffset,\n      viewportOffset = _ref5$viewportOffset === void 0 ? 8 : _ref5$viewportOffset;\n  var isHorizontal = isAlignedHorizontal(position); // Handle left and right positions\n\n  if (isHorizontal) {\n    var leftRect = getRect({\n      position: Position.LEFT,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    var rightRect = getRect({\n      position: Position.RIGHT,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    var fitsOnLeft = getFitsOnLeft(leftRect, viewportOffset);\n    var fitsOnRight = getFitsOnRight(rightRect, viewport, viewportOffset);\n\n    if (position === Position.LEFT) {\n      if (fitsOnLeft) {\n        return {\n          position: position,\n          rect: leftRect\n        };\n      }\n\n      if (fitsOnRight) {\n        return {\n          position: Position.RIGHT,\n          rect: rightRect\n        };\n      }\n    }\n\n    if (position === Position.RIGHT) {\n      if (fitsOnRight) {\n        return {\n          position: position,\n          rect: rightRect\n        };\n      }\n\n      if (fitsOnLeft) {\n        return {\n          position: Position.LEFT,\n          rect: leftRect\n        };\n      }\n    } // Default to using the position with the most space\n\n\n    var spaceRight = Math.abs(viewport.width - viewportOffset - rightRect.right);\n    var spaceLeft = Math.abs(leftRect.left - viewportOffset);\n\n    if (spaceRight < spaceLeft) {\n      return {\n        position: Position.RIGHT,\n        rect: rightRect\n      };\n    }\n\n    return {\n      position: Position.LEFT,\n      rect: leftRect\n    };\n  }\n\n  var positionIsAlignedOnTop = isAlignedOnTop(position);\n  var topRect;\n  var bottomRect;\n\n  if (positionIsAlignedOnTop) {\n    topRect = getRect({\n      position: position,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    bottomRect = getRect({\n      position: flipHorizontal(position),\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n  } else {\n    topRect = getRect({\n      position: flipHorizontal(position),\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    bottomRect = getRect({\n      position: position,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n  }\n\n  var topRectFitsOnTop = getFitsOnTop(topRect, viewportOffset);\n  var bottomRectFitsOnBottom = getFitsOnBottom(bottomRect, viewport, viewportOffset);\n\n  if (positionIsAlignedOnTop) {\n    if (topRectFitsOnTop) {\n      return {\n        position: position,\n        rect: topRect\n      };\n    }\n\n    if (bottomRectFitsOnBottom) {\n      return {\n        position: flipHorizontal(position),\n        rect: bottomRect\n      };\n    }\n  }\n\n  if (!positionIsAlignedOnTop) {\n    if (bottomRectFitsOnBottom) {\n      return {\n        position: position,\n        rect: bottomRect\n      };\n    }\n\n    if (topRectFitsOnTop) {\n      return {\n        position: flipHorizontal(position),\n        rect: topRect\n      };\n    }\n  } // Default to most spacious if there is no fit.\n\n\n  var spaceBottom = Math.abs(viewport.height - viewportOffset - bottomRect.bottom);\n  var spaceTop = Math.abs(topRect.top - viewportOffset);\n\n  if (spaceBottom < spaceTop) {\n    return {\n      position: positionIsAlignedOnTop ? flipHorizontal(position) : position,\n      rect: bottomRect\n    };\n  }\n\n  return {\n    position: positionIsAlignedOnTop ? position : flipHorizontal(position),\n    rect: topRect\n  };\n}\n/**\n * Function that takes in numbers and position and gives the final coords.\n * @param {Position} position\n * @param {Number} targetOffset - offset from the target.\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Rect} targetRect — the rect of the target.\n * @return {Rect} - Rect { width, height, left, top, right, bottom }\n */\n\n\nfunction getRect(_ref6) {\n  var dimensions = _ref6.dimensions,\n      position = _ref6.position,\n      targetOffset = _ref6.targetOffset,\n      targetRect = _ref6.targetRect;\n  var leftRect = targetRect.left + targetRect.width / 2 - dimensions.width / 2;\n  var alignedTopY = targetRect.top - dimensions.height - targetOffset;\n  var alignedBottomY = targetRect.bottom + targetOffset;\n  var alignedRightX = targetRect.right - dimensions.width;\n  var alignedLeftRightY = targetRect.top + targetRect.height / 2 - dimensions.height / 2;\n\n  switch (position) {\n    case Position.LEFT:\n      return makeRect(dimensions, {\n        left: targetRect.left - dimensions.width - targetOffset,\n        top: alignedLeftRightY\n      });\n\n    case Position.RIGHT:\n      return makeRect(dimensions, {\n        left: targetRect.right + targetOffset,\n        top: alignedLeftRightY\n      });\n\n    case Position.TOP:\n      return makeRect(dimensions, {\n        left: leftRect,\n        top: alignedTopY\n      });\n\n    case Position.TOP_LEFT:\n      return makeRect(dimensions, {\n        left: targetRect.left,\n        top: alignedTopY\n      });\n\n    case Position.TOP_RIGHT:\n      return makeRect(dimensions, {\n        left: alignedRightX,\n        top: alignedTopY\n      });\n\n    default:\n    case Position.BOTTOM:\n      return makeRect(dimensions, {\n        left: leftRect,\n        top: alignedBottomY\n      });\n\n    case Position.BOTTOM_LEFT:\n      return makeRect(dimensions, {\n        left: targetRect.left,\n        top: alignedBottomY\n      });\n\n    case Position.BOTTOM_RIGHT:\n      return makeRect(dimensions, {\n        left: alignedRightX,\n        top: alignedBottomY\n      });\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}